API_GEMINI = AIzaSyAYPHOEX1bLo75hsM8WMl7lZKa7pz4wwtA




from datetime import datetime, timedelta, date

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import streamlit as st
import yfinance as yf
from yahooquery import Ticker as YQTicker  # fuente principal

APP_VERSION = "FinanzasUP v6.0 ‚Äî yahooquery + fallbacks (anti-KeyError)"

try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except Exception:
    GEMINI_AVAILABLE = False

TRADING_DAYS = {"1d": 252, "1wk": 52, "1mo": 12}


def configure_page() -> None:
    st.set_page_config(
        page_title="FinanzasUP ‚Äî An√°lisis de Acciones/ETFs",
        page_icon="üìà",
        layout="wide",
    )


@st.cache_resource(show_spinner=False)
def init_gemini(api_key: str | None):
    if not GEMINI_AVAILABLE or not api_key:
        return None
    genai.configure(api_key=api_key)
    try:
        return genai.GenerativeModel("gemini-1.5-flash")
    except Exception:
        return None


def translate_with_gemini(model, text: str, target_lang: str = "es") -> str:
    if not model or not text:
        return text or "No hay descripci√≥n disponible"
    prompt = (
        "Traduce al espa√±ol claro y conciso, m√°ximo ~1200 caracteres. "
        "Conserva t√©rminos financieros relevantes sin notas al pie.\n\n"
        f"Texto:\n{text}"
    )
    try:
        resp = model.generate_content(prompt)
        return resp.text.strip() if getattr(resp, "text", "").strip() else text
    except Exception:
        return text


def _to_1d_numeric(x):
    if isinstance(x, pd.DataFrame):
        x = x.iloc[:, 0]
    return pd.to_numeric(getattr(x, "squeeze", lambda: x)(), errors="coerce")


def _normalize_ohlc(df: pd.DataFrame) -> pd.DataFrame:
    cols_final = ["Date", "Open", "High", "Low", "Close", "Adj Close", "Volume"]
    if df is None or df.empty:
        return pd.DataFrame(columns=cols_final)

    df = df.reset_index().rename(columns=str.title)
    if "Date" not in df.columns and "Datetime" in df.columns:
        df = df.rename(columns={"Datetime": "Date"})

    if "Close" not in df.columns and "Adj Close" in df.columns:
        df["Close"] = df["Adj Close"]

    if "Close" in df.columns:
        for c in ["Open", "High", "Low"]:
            if c not in df.columns:
                df[c] = df["Close"]

    for c in cols_final:
        if c not in df.columns:
            df[c] = np.nan

    df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
    for c in ["Open", "High", "Low", "Close", "Adj Close", "Volume"]:
        df[c] = _to_1d_numeric(df[c])

    df = df.dropna(subset=["Date", "Close"])
    return df[cols_final].sort_values("Date").reset_index(drop=True)


@st.cache_data(show_spinner=False)
def fetch_ohlc(symbol: str, start_dt: datetime, end_dt: datetime, interval: str, version: int = 6) -> pd.DataFrame:
    # 1) yahooquery (estable y sin MultiIndex raros)
    try:
        yq = YQTicker(symbol)
        yq_interval = {"1d": "1d", "1wk": "1wk", "1mo": "1mo"}[interval]
        yq_hist = yq.history(start=start_dt.date(), end=end_dt.date(), interval=yq_interval)
        if isinstance(yq_hist, pd.DataFrame) and not yq_hist.empty:
            if "symbol" in yq_hist.columns:
                yq_hist = yq_hist.drop(columns=["symbol"])
            yq_hist = yq_hist.rename(
                columns={
                    "open": "Open",
                    "high": "High",
                    "low": "Low",
                    "close": "Close",
                    "adjclose": "Adj Close",
                    "adj_close": "Adj Close",
                    "volume": "Volume",
                }
            )
            if isinstance(yq_hist.index, pd.MultiIndex):
                yq_hist.index = yq_hist.index.get_level_values(-1)
            yq_hist = yq_hist.reset_index().rename(columns={"index": "Date"})
            out = _normalize_ohlc(yq_hist)
            if not out.empty:
                return out
    except Exception:
        pass

    # 2) yfinance: Ticker.history (mejor que download)
    try:
        tk = yf.Ticker(symbol)
        yf_hist = tk.history(
            start=start_dt,
            end=end_dt,
            interval=interval,
            actions=False,
            auto_adjust=False,
        )
        out = _normalize_ohlc(yf_hist)
        if not out.empty:
            return out
    except Exception:
        pass

    # 3) yfinance: download (√∫ltimo recurso)
    try:
        dl = yf.download(
            symbol,
            start=start_dt,
            end=end_dt,
            interval=interval,
            auto_adjust=False,
            progress=False,
        )
        if isinstance(dl.columns, pd.MultiIndex):
            dl.columns = ["_".join([str(x) for x in t if x]) for t in dl.columns]
        rename_map = {}
        for c in list(dl.columns):
            uc = c.upper()
            if "OPEN" in uc and "Open" not in rename_map.values():
                rename_map[c] = "Open"
            if "HIGH" in uc and "High" not in rename_map.values():
                rename_map[c] = "High"
            if "LOW" in uc and "Low" not in rename_map.values():
                rename_map[c] = "Low"
            if uc.endswith("CLOSE") and "Close" not in rename_map.values():
                rename_map[c] = "Close"
            if "ADJ" in uc and "CLOSE" in uc and "Adj Close" not in rename_map.values():
                rename_map[c] = "Adj Close"
            if "VOLUME" in uc and "Volume" not in rename_map.values():
                rename_map[c] = "Volume"
        dl = dl.rename(columns=rename_map)
        return _normalize_ohlc(dl)
    except Exception:
        return pd.DataFrame(columns=["Date", "Open", "High", "Low", "Close", "Adj Close", "Volume"])


def pct_change(series: pd.Series) -> pd.Series:
    return series.pct_change().replace([np.inf, -np.inf], np.nan).dropna()


def cumulative_returns(returns: pd.Series) -> pd.Series:
    return (1 + returns).cumprod() - 1


def max_drawdown(equity_curve: pd.Series) -> float:
    if equity_curve.empty:
        return np.nan
    peak = equity_curve.cummax()
    dd = equity_curve / peak - 1.0
    return float(dd.min())


def annualized_vol(returns: pd.Series, interval: str) -> float:
    periods = TRADING_DAYS.get(interval, 252)
    return float(returns.std(ddof=0) * np.sqrt(periods))


def sharpe_ratio(returns: pd.Series, interval: str, rf_annual: float = 0.0) -> float:
    periods = TRADING_DAYS.get(interval, 252)
    rf_periodic = (1 + rf_annual) ** (1 / periods) - 1
    excess = returns - rf_periodic
    vol = excess.std(ddof=0)
    if vol == 0 or np.isnan(vol):
        return np.nan
    return float(excess.mean() / vol * np.sqrt(periods))


def var_es(returns: pd.Series, level: float = 0.95) -> tuple[float, float]:
    if returns.empty:
        return np.nan, np.nan
    q = np.quantile(returns.dropna(), 1 - level)
    tail = returns[returns <= q]
    es = tail.mean() if not tail.empty else np.nan
    return float(q), float(es)


def beta_vs_benchmark(asset_ret: pd.Series, bench_ret: pd.Series) -> float:
    joined = pd.concat([asset_ret, bench_ret], axis=1, join="inner").dropna()
    if joined.shape[0] < 3:
        return np.nan
    cov = np.cov(joined.iloc[:, 0], joined.iloc[:, 1])[0, 1]
    var = np.var(joined.iloc[:, 1])
    if var == 0:
        return np.nan
    return float(cov / var)


def build_candles(df: pd.DataFrame, title: str) -> go.Figure:
    fig = go.Figure()
    fig.add_trace(
        go.Candlestick(
            x=df["Date"],
            open=df["Open"],
            high=df["High"],
            low=df["Low"],
            close=df["Close"],
            name="OHLC",
        )
    )
    ma20 = df["Close"].rolling(20).mean()
    ma50 = df["Close"].rolling(50).mean()
    fig.add_trace(go.Scatter(x=df["Date"], y=ma20, mode="lines", name="MA20"))
    fig.add_trace(go.Scatter(x=df["Date"], y=ma50, mode="lines", name="MA50"))
    fig.update_layout(title=title, xaxis_title="Fecha", yaxis_title="Precio", hovermode="x unified")
    return fig


def build_volume(df: pd.DataFrame, title: str) -> go.Figure:
    fig = go.Figure()
    fig.add_trace(go.Bar(x=df["Date"], y=df["Volume"], name="Volumen"))
    fig.update_layout(title=title, xaxis_title="Fecha", yaxis_title="Volumen", hovermode="x unified")
    return fig


def rsi(series: pd.Series, window: int = 14) -> pd.Series:
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    ma_up = up.ewm(alpha=1 / window, adjust=False).mean()
    ma_down = down.ewm(alpha=1 / window, adjust=False).mean()
    rs = ma_up / ma_down.replace(0, np.nan)
    return 100 - (100 / (1 + rs))


def build_rsi(df: pd.DataFrame) -> go.Figure:
    r = rsi(df["Close"])
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df["Date"], y=r, mode="lines", name="RSI"))
    fig.add_hrect(y0=70, y1=70, line_width=1, line_dash="dot")
    fig.add_hrect(y0=30, y1=30, line_width=1, line_dash="dot")
    fig.update_layout(title="RSI (14)", xaxis_title="Fecha", yaxis_title="RSI", hovermode="x unified")
    return fig


def risk_summary_spa(metrics: dict) -> list[str]:
    vol = metrics.get("vol")
    mdd = metrics.get("mdd")
    sr = metrics.get("sharpe")
    beta = metrics.get("beta")
    var_ = metrics.get("var")
    es_ = metrics.get("es")

    lines = []
    if not np.isnan(vol):
        lines.append(f"Volatilidad anualizada: {vol:.2%}. Mayor volatilidad implica variaciones de precio m√°s amplias.")
    if not np.isnan(mdd):
        lines.append(f"Drawdown m√°ximo: {mdd:.2%}. Estima la peor ca√≠da pico-a-valle del periodo observado.")
    if not np.isnan(sr):
        lines.append(f"Sharpe: {sr:.2f}. Eficiencia del retorno ajustado por riesgo frente a la volatilidad.")
    if not np.isnan(beta):
        posture = "m√°s sensible que el mercado" if beta > 1 else "menos sensible que el mercado"
        lines.append(f"Beta vs benchmark: {beta:.2f}, {posture}. Mide la exposici√≥n sistem√°tica.")
    if not np.isnan(var_):
        lines.append(f"VaR 95% diario: {var_:.2%}. P√©rdida m√≠nima esperada en el peor 5% de los d√≠as.")
    if not np.isnan(es_):
        lines.append(f"ES 95% diario: {es_:.2%}. P√©rdida promedio condicionada a estar en ese 5% peor.")
    return lines


@st.cache_data(show_spinner=False)
def fetch_info(symbol: str) -> dict:
    try:
        tk = yf.Ticker(symbol)
        return tk.info or {}
    except Exception:
        return {}


def company_explainer(info: dict, translated: str) -> dict:
    name = info.get("longName") or info.get("shortName") or "Nombre no disponible"
    sector = info.get("sector") or "Sector no disponible"
    industry = info.get("industry") or "Industria no disponible"
    country = info.get("country") or "Pa√≠s no disponible"
    website = info.get("website") or "Sitio no disponible"
    return {
        "name": name,
        "sector": sector,
        "industry": industry,
        "country": country,
        "website": website,
        "description_es": translated,
    }


def clamp_dates(d_start: date, d_end: date) -> tuple[date, date]:
    today = datetime.today().date()
    if d_end > today:
        d_end = today
    if d_start >= d_end:
        d_start = d_end - timedelta(days=365)
    return d_start, d_end


def main() -> None:
    configure_page()
    st.caption(APP_VERSION)

    st.title("üìà Rendimientos y Riesgos ‚Äî Acciones/ETFs (Yahoo Finance)")

    with st.sidebar:
        st.header("Par√°metros")
        ticker = st.text_input("S√≠mbolo", value="SPY").strip().upper()
        benchmark = st.text_input("Benchmark (beta y comparaci√≥n)", value="^GSPC").strip().upper()
        today = datetime.today().date()
        default_start = today - timedelta(days=5 * 365)
        start = st.date_input("Inicio", value=default_start)
        end = st.date_input("Fin", value=today)
        start, end = clamp_dates(start, end)
        interval = st.selectbox("Intervalo", options=["1d", "1wk", "1mo"], index=0)
        rf = st.number_input("Tasa libre de riesgo anual (%)", value=4.0, step=0.25) / 100.0
        show_adj = st.toggle("Usar Ajustado (Adj Close) para retornos", value=True)
        debug = st.toggle("Modo debug", value=False)
        st.divider()
        api_key = st.text_input("GEMINI_API_KEY (opcional)", type="password")
        model = init_gemini(api_key)

    df = fetch_ohlc(
        ticker,
        datetime.combine(start, datetime.min.time()),
        datetime.combine(end, datetime.min.time()),
        interval,
        version=6,
    )
    if df.empty:
        st.warning("Sin datos para el s√≠mbolo/fechas/intervalo seleccionados.")
        st.stop()

    if debug:
        st.code(f"Columnas {ticker}: {list(df.columns)}")
        st.write(df.head())

    price_col = "Adj Close" if show_adj and "Adj Close" in df.columns else "Close"
    ret = pct_change(df[price_col])

    bench_df = fetch_ohlc(
        benchmark,
        datetime.combine(start, datetime.min.time()),
        datetime.combine(end, datetime.min.time()),
        interval,
        version=6,
    )
    if debug and not bench_df.empty:
        st.code(f"Columnas {benchmark}: {list(bench_df.columns)}")

    bench_ret = (
        pct_change(bench_df["Adj Close"] if (not bench_df.empty and "Adj Close" in bench_df.columns) else bench_df["Close"])
        if not bench_df.empty
        else pd.Series(dtype=float)
    )

    vol = annualized_vol(ret, interval)
    sr = sharpe_ratio(ret, interval, rf)
    eq = (1 + ret).cumprod()
    mdd = max_drawdown(eq)
    var95, es95 = var_es(ret, 0.95)
    beta = beta_vs_benchmark(ret, bench_ret) if not bench_ret.empty else np.nan

    info = fetch_info(ticker)
    original_desc = info.get("longBusinessSummary", "") or ""
    translated_desc = translate_with_gemini(model, original_desc, "es")
    details = company_explainer(info, translated_desc)

    t1, t2, t3, t4, t5 = st.tabs(["Resumen", "Gr√°ficas", "Riesgos", "M√©tricas", "Datos"])

    with t1:
        c1, c2, c3, c4 = st.columns([2, 1, 1, 1])
        c1.metric("S√≠mbolo", ticker)
        c2.metric("Volatilidad anual", f"{vol:.2%}" if not np.isnan(vol) else "‚Äî")
        c3.metric("Sharpe", f"{sr:.2f}" if not np.isnan(sr) else "‚Äî")
        c4.metric("Drawdown m√°x.", f"{mdd:.2%}" if not np.isnan(mdd) else "‚Äî")

        st.subheader(details["name"])
        colA, colB = st.columns(2)
        with colA:
            st.write(f"**Sector:** {details['sector']}")
            st.write(f"**Industria:** {details['industry']}")
            st.write(f"**Pa√≠s:** {details['country']}")
            st.write(f"**Sitio:** {details['website']}")
        with colB:
            st.write(f"**Periodo:** {start.strftime('%Y-%m-%d')} ‚Üí {end.strftime('%Y-%m-%d')}")
            st.write(f"**Benchmark:** {benchmark}")
            st.write(f"**Precio usado:** {price_col}")

        st.markdown("**Descripci√≥n (ingl√©s)**")
        st.write(original_desc or "No hay descripci√≥n disponible")
        st.markdown("**Descripci√≥n traducida (Gemini)**")
        st.write(details["description_es"] or "No hay descripci√≥n disponible")

        st.markdown("**Rendimiento acumulado**")
        cum_fig = go.Figure()
        cum_fig.add_trace(go.Scatter(x=df["Date"].iloc[1:], y=cumulative_returns(ret), mode="lines", name=ticker))
        if not bench_ret.empty:
            cum_bench = cumulative_returns(bench_ret)
            cum_fig.add_trace(go.Scatter(x=bench_df["Date"].iloc[1:], y=cum_bench, mode="lines", name=benchmark))
        cum_fig.update_layout(xaxis_title="Fecha", yaxis_title="Rendimiento acumulado", hovermode="x unified")
        st.plotly_chart(cum_fig, use_container_width=True)

    with t2:
        st.subheader("Velas japonesas + MAs")
        st.plotly_chart(build_candles(df, f"{ticker} ‚Äî OHLC"), use_container_width=True)
        c_left, c_right = st.columns(2)
        with c_left:
            st.subheader("Volumen")
            st.plotly_chart(build_volume(df, f"{ticker} ‚Äî Volumen"), use_container_width=True)
        with c_right:
            st.subheader("RSI (14)")
            st.plotly_chart(build_rsi(df), use_container_width=True)

    with t3:
        st.subheader("Mapa de riesgos")
        bullets = risk_summary_spa({"vol": vol, "mdd": mdd, "sharpe": sr, "beta": beta, "var": var95, "es": es95})
        if bullets:
            for b in bullets:
                st.write(f"- {b}")
        else:
            st.write("No fue posible calcular m√©tricas de riesgo con los datos actuales.")
        st.info(
            "Interpretaci√≥n: la volatilidad y el drawdown reflejan riesgo total; el Sharpe eval√∫a eficiencia del retorno; "
            "beta mide riesgo sistem√°tico frente al benchmark; VaR/ES estiman p√©rdidas extremas hist√≥ricas. "
            "Ninguna m√©trica garantiza resultados futuros."
        )

    with t4:
        c1, c2, c3 = st.columns(3)
        c1.metric("Beta", f"{beta:.2f}" if not np.isnan(beta) else "‚Äî")
        c2.metric("VaR 95% (diario)", f"{var95:.2%}" if not np.isnan(var95) else "‚Äî")
        c3.metric("ES 95% (diario)", f"{es95:.2%}" if not np.isnan(es95) else "‚Äî")

        st.markdown("### Serie de drawdown")
        dd = eq / eq.cummax() - 1
        dd_fig = go.Figure()
        dd_fig.add_trace(go.Scatter(x=df["Date"].iloc[1:], y=dd, mode="lines", name="Drawdown"))
        dd_fig.update_layout(xaxis_title="Fecha", yaxis_title="Drawdown", hovermode="x unified")
        st.plotly_chart(dd_fig, use_container_width=True)

        st.markdown("### Volatilidad m√≥vil (21)")
        rolling_vol = ret.rolling(21).std() * np.sqrt(TRADING_DAYS.get(interval, 252))
        rv_fig = go.Figure()
        rv_fig.add_trace(go.Scatter(x=df["Date"].iloc[1:], y=rolling_vol, mode="lines", name="Vol m√≥vil 21"))
        rv_fig.update_layout(xaxis_title="Fecha", yaxis_title="Vol anualizada", hovermode="x unified")
        st.plotly_chart(rv_fig, use_container_width=True)

    with t5:
        st.download_button(
            label="Descargar CSV",
            data=df.to_csv(index=False).encode("utf-8"),
            file_name=f"{ticker}_{start}_{end}_{interval}.csv",
            mime="text/csv",
        )
        st.dataframe(df, use_container_width=True, height=500)

    st.divider()
    st.markdown("**¬© 2025 FinanzasUP. Desarrollado por Carlos Santana ‚Äî FinanzasUP.**")


if __name__ == "__main__":
    main()
